{
  "generatedAt": "2025-11-21T11:21:02.208Z",
  "automationPath": "C:\\Users\\stuar\\Projects\\fairway_sniper\\automation",
  "env": {
    "FS_EMAIL": "your_chosen_email@example.com",
    "FS_PASSWORD": "<REDACTED>",
    "FS_USERNAME": "12390624",
    "FS_DRY_RUN": "true",
    "FS_TARGET_DATE": "2025-10-25",
    "FS_TARGET_TIMES": "07:56,08:04",
    "FS_CLICK_WAITLIST": "false"
  },
  "stateJson": {
    "exists": true
  },
  "files": {
    "package.json": "{\n  \"name\": \"automation\",\n  \"type\": \"module\",\n  \"version\": \"1.0.0\",\n  \"private\": true,\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"node -r dotenv/config ./node_modules/@playwright/test/cli.js\",\n    \"codegen\": \"npx playwright codegen\"\n  },\n  \"keywords\": [],\n  \"author\": \"\",\n  \"license\": \"ISC\",\n  \"description\": \"\",\n  \"devDependencies\": {\n    \"@playwright/test\": \"^1.56.1\",\n    \"@types/node\": \"^24.8.1\",\n    \"date-fns-tz\": \"^1.3.8\",\n    \"dotenv\": \"^17.2.3\",\n    \"ts-node\": \"^10.9.2\",\n    \"typescript\": \"^5.9.3\"\n  }\n}\n",
    "tsconfig.json": "{\r\n  // Visit https://aka.ms/tsconfig to read more about this file\r\n  \"compilerOptions\": {\r\n    // File Layout\r\n    \"rootDir\": \".\",\r\n    \"outDir\": \"dist\",\r\n\r\n    // Environment Settings\r\n    // See also https://aka.ms/tsconfig/module\r\n  \"module\": \"nodenext\",\r\n  \"moduleResolution\": \"nodenext\",\r\n    \"target\": \"es2022\",\r\n    \"types\": [\r\n      \"node\",\r\n      \"@playwright/test\"\r\n    ],\r\n    // For nodejs:\r\n    // \"lib\": [\"esnext\"],\r\n    // \"types\": [\"node\"],\r\n    // and npm install -D @types/node\r\n\r\n    // Other Outputs\r\n    \"sourceMap\": true,\r\n    \"declaration\": true,\r\n    \"declarationMap\": true,\r\n\r\n    // Stricter Typechecking Options\r\n    \"noUncheckedIndexedAccess\": true,\r\n    \"exactOptionalPropertyTypes\": true,\r\n\r\n    // Style Options\r\n    // \"noImplicitReturns\": true,\r\n    // \"noImplicitOverride\": true,\r\n    // \"noUnusedLocals\": true,\r\n    // \"noUnusedParameters\": true,\r\n    // \"noFallthroughCasesInSwitch\": true,\r\n    // \"noPropertyAccessFromIndexSignature\": true,\r\n\r\n    // Recommended Options\r\n    \"strict\": true,\r\n    \"jsx\": \"react-jsx\",\r\n    \"verbatimModuleSyntax\": true,\r\n    \"isolatedModules\": true,\r\n    \"noUncheckedSideEffectImports\": true,\r\n    \"moduleDetection\": \"force\",\r\n    \"skipLibCheck\": true,\r\n  }\r\n}\r\n",
    "playwright.config.ts": "import 'dotenv/config';\nimport { defineConfig, devices } from '@playwright/test';\n\nconst FAST = process.env.PW_FAST === '1';\nif (FAST) console.log('‚ö° FAST mode (headless, no artifacts)');\n\nexport default defineConfig({\n  testDir: 'tests',\n  timeout: 60_000,\n  use: FAST\n    ? {\n        headless: true,\n        trace: 'off',\n        screenshot: 'off',\n        video: 'off',\n        storageState: 'state.json',\n      }\n    : {\n        headless: false,\n        trace: 'on-first-retry',\n        screenshot: 'only-on-failure',\n        video: 'retain-on-failure',\n        storageState: 'state.json',\n      },\n  projects: [\n    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },\n  ],\n});\n",
    "tests/login.spec.ts": "import { test, expect } from '@playwright/test';\n\ntest('manual login bootstrap', async ({ page, context }) => {\n  // Correct login page\n  await page.goto('https://members.brsgolf.com/galgorm/login');\n\n  // Use GUI/ILGU username if provided, else fallback to email\n  const USER = process.env.FS_USERNAME ?? process.env.FS_EMAIL ?? '';\n\n  // Fill login form using robust selectors\n  await page.getByPlaceholder(/8 digit GUI|username/i).fill(USER);\n  await page.getByPlaceholder(/password/i).fill(process.env.FS_PASSWORD ?? '');\n\n  // Click LOGIN\n  await page.getByRole('button', { name: /login/i }).click();\n\n  // Save session immediately after login for reuse\n  await page.context().storageState({ path: 'state.json' });\n\n  // Wait for navigation to a logged-in page\n  await page.waitForLoadState('networkidle');\n  await expect(page).toHaveURL(/dashboard|bookings|account/i);\n\n  // session already saved above\n});\n",
    "tests/book_slot.spec.ts": "import 'dotenv/config';\nimport { test, expect } from '@playwright/test';\n\n// Async loader for date-fns-tz to handle ESM/CJS differences at runtime\nasync function getZonedTimeToUtc() {\n  try {\n    const mod = await import('date-fns-tz');\n    return (mod as any).zonedTimeToUtc ?? (mod as any).default?.zonedTimeToUtc ?? (mod as any);\n  } catch (e) {\n    // Fallback to require via createRequire for older environments\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    const { createRequire } = await import('module');\n    const req = createRequire(import.meta.url);\n    const _df = req('date-fns-tz');\n    return _df.zonedTimeToUtc ?? _df.default?.zonedTimeToUtc ?? _df;\n  }\n}\n\n// Use authenticated state saved previously\ntest.use({ storageState: 'state.json' });\n\n// Helper: parse environment variables with defaults\nconst env: {\n  DRY_RUN: boolean;\n  RAW_TARGET_DATE: string;\n  TARGET_DAY: string | undefined; // day number as string (e.g. '25')\n  TARGET_TIMES: string[];\n  CLICK_WAITLIST: boolean;\n} = {\n  DRY_RUN: (process.env.FS_DRY_RUN ?? 'true').toLowerCase() === 'true',\n  RAW_TARGET_DATE: (process.env.FS_TARGET_DATE ?? '').trim(),\n  TARGET_DAY: undefined,\n  TARGET_TIMES: (process.env.FS_TARGET_TIMES ?? '').split(',').map((s) => s.trim()).filter(Boolean),\n  CLICK_WAITLIST: (process.env.FS_CLICK_WAITLIST ?? 'false').toLowerCase() === 'true',\n};\n\n// How many days ahead to scan when current date has no actionable slots\nconst SEARCH_DAYS = Number(process.env.FS_SEARCH_DAYS ?? '14');\n\n// Timezone-aware release configuration\n// .env values:\n// FS_RELEASE_AT_LOCAL=2025-10-25T07:00:00  (local clock in the target timezone)\n// FS_TZ=Europe/London\nconst TZ = process.env.FS_TZ || 'Europe/London';\nconst RELEASE_AT_LOCAL = process.env.FS_RELEASE_AT_LOCAL || '';\n// Will be computed at runtime inside the test to avoid module loading issues\nlet RELEASE_AT: Date | null = null;\n\n// Interpret RAW_TARGET_DATE: accept YYYY-MM-DD or just day number like '25'\nif (env.RAW_TARGET_DATE) {\n  const isoMatch = env.RAW_TARGET_DATE.match(/^\\d{4}-\\d{2}-\\d{2}$/);\n  if (isoMatch) {\n    const d = new Date(env.RAW_TARGET_DATE);\n    if (!Number.isNaN(d.getTime())) {\n      env.TARGET_DAY = String(d.getDate());\n    } else {\n      // fallback to last number group\n      const m = env.RAW_TARGET_DATE.match(/(\\d{1,2})$/);\n      env.TARGET_DAY = m ? String(Number(m[1])) : undefined;\n    }\n  } else {\n    const m = env.RAW_TARGET_DATE.match(/^(\\d{1,2})$/);\n    env.TARGET_DAY = m ? String(Number(m[1])) : undefined;\n  }\n}\n// Helper: open the calendar robustly\nasync function openCalendar(page: import('@playwright/test').Page) {\n  const dateBtn = page.locator('button', { hasText: /JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC/i }).first();\n  await dateBtn.waitFor({ state: 'visible', timeout: 7000 });\n  await dateBtn.click();\n\n  // Wait for any known calendar overlay/panel to appear. Different sites use\n  // different datepicker implementations, so try a few selectors.\n  const calendarSelectors = [\n    '.mat-calendar',\n    '.mat-datepicker-content',\n    '.mat-datepicker-popup',\n    '.cdk-overlay-container .mat-calendar',\n    '.ui-datepicker',\n    '.datepicker',\n    '[role=\"dialog\"]',\n  ];\n\n  const start = Date.now();\n  const timeout = 9000;\n  while (Date.now() - start < timeout) {\n    for (const sel of calendarSelectors) {\n      if (await page.locator(sel).first().isVisible().catch(() => false)) {\n        console.log('üìÖ Calendar opened via selector', sel);\n        return;\n      }\n    }\n\n    // Fallback: sometimes the calendar is rendered inline without a wrapper\n    // but day cells/buttons appear. Detect any day-like button or cell.\n    const dayLike = page.locator('button:has-text(\"1\"), button:has-text(\"2\"), button:has-text(\"3\"), .mat-calendar-body-cell, .ui-datepicker-day').first();\n    if (await dayLike.isVisible().catch(() => false)) {\n      console.log('üìÖ Calendar-like day cell visible');\n      return;\n    }\n\n    await page.waitForTimeout(200);\n  }\n\n  // If we didn't detect a calendar, surface a helpful message for debugging.\n  throw new Error('Calendar did not appear after clicking date button (checked several selectors)');\n}\n\n// Helper: try to select a calendar day, hopping months up to maxHops\nasync function selectCalendarDay(page: import('@playwright/test').Page, day: string, maxHops = 12) {\n  // Try current and up to maxHops next months\n  for (let i = 0; i <= maxHops; i++) {\n    // Try a bunch of selectors for enabled day cells/buttons across implementations\n    const daySelectors = [\n      `.mat-calendar-body-cell:not(.mat-calendar-body-disabled) .mat-calendar-body-cell-content:text-is(\"${day}\")`,\n      `.mat-calendar-body-cell-content:text-is(\"${day}\")`,\n      `button:has-text(\"${day}\")`,\n      `.ui-datepicker-calendar td:not(.ui-datepicker-unselectable) :text-is(\"${day}\")`,\n      `.datepicker td:not(.disabled) :text-is(\"${day}\")`,\n      `text(\"${day}\")`,\n    ];\n\n    for (const sel of daySelectors) {\n      const enabledDay = page.locator(sel).first();\n      if (await enabledDay.isVisible().catch(() => false)) {\n        console.log(`üìÖ Clicking day ${day} on month hop ${i} using selector ${sel}`);\n        await enabledDay.click().catch(() => {});\n        return true;\n      }\n    }\n\n    // Go to next month and retry\n    const nextBtn = page.locator('.mat-calendar-next-button, button[aria-label=\"Next month\"], button.mat-calendar-next-button').first();\n    if (await nextBtn.isVisible().catch(() => false)) {\n      await nextBtn.click();\n      await page.waitForTimeout(250);\n    } else {\n      break;\n    }\n  }\n  return false;\n}\n\n// Helper: ensure the page is logged in, perform auto-login fallback and refresh state.json\nasync function ensureLoggedIn(page: import('@playwright/test').Page) {\n  // If already past login, return\n  if (!/\\/login\\b/i.test(page.url())) return;\n\n  const USER = process.env.FS_USERNAME ?? process.env.FS_EMAIL ?? '';\n  const PASS = process.env.FS_PASSWORD ?? '';\n\n  // Fill by placeholders to be resilient\n  const userInput = page.getByPlaceholder(/8 digit GUI|ILGU|username/i).first();\n  const passInput = page.getByPlaceholder(/password/i).first();\n  await userInput.waitFor({ state: 'visible', timeout: 8000 });\n  await userInput.fill(USER);\n  await passInput.fill(PASS);\n\n  await page.getByRole('button', { name: /login/i }).first().click();\n\n  // Wait for a logged-in signal: left nav or Book a Tee Time button\n  const loggedInSignal = page.getByRole('link', { name: /tee sheet/i }).first()\n    .or(page.getByRole('button', { name: /book a tee time/i }).first());\n  await loggedInSignal.waitFor({ state: 'visible', timeout: 15000 });\n\n  // Persist refreshed cookies for future runs\n  await page.context().storageState({ path: 'state.json' });\n  console.log('üîê Auto-login complete, state.json refreshed');\n}\n\n// Returns a Locator root that points either to the tee iframe‚Äôs document, or the page if no iframe.\nasync function rootForTee(page: import('@playwright/test').Page) {\n  const candidates = [\n    'iframe[src*=\"tee\"]',\n    'iframe[id*=\"tee\"]',\n    'iframe[src*=\"sheet\"]',\n    'iframe' // fallback\n  ];\n  const timePattern = 'text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/';\n  for (const sel of candidates) {\n    try {\n      const count = await page.locator(sel).count();\n      if (count === 0) continue;\n      const fl = page.frameLocator(sel);\n      const hasTime = await fl.locator(timePattern).first().count().catch(() => 0);\n      if (hasTime > 0) {\n        console.log('üîé Using frameLocator for selector', sel);\n        return fl;\n      }\n    } catch (e) {\n      // ignore and try next selector\n    }\n  }\n  return page;\n}\n\n// Finds the row for a given time string by locating a TD that matches the time and then its sibling action cell.\nasync function findRowAndAction(root: any, time: string) {\n  // time cell: exact text match like 07:56 (trim whitespace)\n  const timeCell = root.locator(`td:has-text(\"${time}\")`).first()\n    .or(root.locator(`.tee-time:has-text(\"${time}\")`).first());\n  await timeCell.waitFor({ state: 'visible', timeout: 12000 });\n\n  // Row is the ancestor tr (or a div row as fallback)\n  const row = timeCell.locator('xpath=ancestor::tr | ancestor::div[contains(@class,\"row\") or contains(@class,\"tee\")]').first();\n\n  // Action cell/buttons within the same row\n  const bookBtn = row.locator('button:has-text(\"Book\"), a:has-text(\"Book\"), [role=\"button\"]:has-text(\"Book\")').first();\n  const waitBtn = row.locator('button:has-text(\"Waiting\"), button:has-text(\"Waiting List\"), a:has-text(\"Waiting\")').first();\n\n  return { row, bookBtn, waitBtn };\n}\n\n// Table-aware fallback: scan table rows and find a matching time cell and its action cell\nasync function findRowAndActionTable(root: any, time: string) {\n  // Find a tee table/grid\n  const table = root.locator('table:has(tr), [role=\"grid\"]:has(tr)').first();\n  await table.waitFor({ state: 'visible', timeout: 8000 });\n\n  const rows = table.locator('tbody tr, tr');\n  const count = await rows.count();\n  for (let i = 0; i < count; i++) {\n    const row = rows.nth(i);\n    const cells = row.locator('td, [role=\"gridcell\"]');\n    const firstCell = cells.first();\n    const t = (await firstCell.innerText().catch(() => '')).trim();\n\n    if (t === time) {\n      // Typical action cell is not the first one\n      const actionCell = cells.nth(1).or(cells.nth(2)).or(row); // fallback to row\n      const bookBtn = actionCell.locator('button:has-text(/\\\\bbook\\\\b/i), a:has-text(/\\\\bbook\\\\b/i), [role=\"button\"]:has-text(/\\\\bbook\\\\b/i)').first();\n      const waitBtn  = actionCell.locator('button:has-text(/waiting( list)?/i), a:has-text(/waiting( list)?/i), [role=\"button\"]:has-text(/waiting( list)?/i)').first();\n      return { row, bookBtn, waitBtn };\n    }\n  }\n  return { row: rows.first(), bookBtn: root.locator('_no_match_'), waitBtn: root.locator('_no_match_') };\n}\n\ntest('book first available preferred tee time (safe)', async ({ page }) => {\n  test.setTimeout(180_000);\n\n  console.log('‚öôÔ∏è Config...', {\n    dryRun: env.DRY_RUN,\n    rawTargetDate: env.RAW_TARGET_DATE,\n    targetDay: env.TARGET_DAY ?? null,\n    targetTimes: env.TARGET_TIMES,\n    searchDays: SEARCH_DAYS,\n    tz: process.env.FS_TZ || 'Europe/London',\n    releaseAtLocal: process.env.FS_RELEASE_AT_LOCAL || null,\n    clickWaitlist: env.CLICK_WAITLIST,\n  });\n\n  // Compute RELEASE_AT at runtime using dynamic loader\n  if (RELEASE_AT_LOCAL) {\n    const _z = await getZonedTimeToUtc();\n    try {\n  RELEASE_AT = _z(RELEASE_AT_LOCAL, TZ);\n  if (RELEASE_AT) console.log('üïí Parsed RELEASE_AT (UTC):', RELEASE_AT.toISOString());\n    } catch (e) {\n      console.log('‚ö†Ô∏è Could not parse RELEASE_AT_LOCAL with date-fns-tz:', e);\n      RELEASE_AT = null;\n    }\n  }\n\n  // Navigate to tee sheet and ensure we're on the tee-sheet page\n  // Ensure navigation starts even if storageState doesn't redirect ‚Äî load the tee-sheet page explicitly\n  await page.goto('https://members.brsgolf.com/galgorm/tee-sheet/1', { waitUntil: 'load' });\n  // Auto-login fallback if storageState didn't redirect us into a logged-in area\n  await ensureLoggedIn(page);\n  // Helper: robust navigation from Home (or other pages) to the tee sheet\n  async function goToTeeSheet(page: import('@playwright/test').Page) {\n    // If we're already on a tee-sheet URL, return\n    if (/\\/tee-sheet\\//.test(page.url())) return;\n\n    // Try left-nav ‚ÄúTee Sheet‚Äù first (button or link)\n    const navTee = page.getByRole('link', { name: /tee sheet/i }).first()\n      .or(page.getByRole('button', { name: /tee sheet/i }).first());\n\n    if (await navTee.isVisible().catch(() => false)) {\n      await navTee.click();\n      return;\n    }\n\n    // Fallback: big ‚ÄúBOOK A TEE TIME‚Äù button on Home\n    const bookBtn = page.getByRole('button', { name: /book a tee time/i }).first();\n    if (await bookBtn.isVisible().catch(() => false)) {\n      try { await bookBtn.scrollIntoViewIfNeeded(); } catch {}\n      await bookBtn.click();\n      return;\n    }\n\n    // Last resort: click a link with ‚ÄúBookings‚Äù then ‚ÄúTee Sheet‚Äù\n    const bookings = page.getByRole('link', { name: /bookings/i }).first()\n      .or(page.getByRole('button', { name: /bookings/i }).first());\n    if (await bookings.isVisible().catch(() => false)) {\n      await bookings.click();\n      const ts = page.getByRole('link', { name: /tee sheet/i }).first()\n        .or(page.getByRole('button', { name: /tee sheet/i }).first());\n      if (await ts.isVisible().catch(() => false)) await ts.click();\n    }\n  }\n  // Try robust navigation from home -> tee sheet if needed\n  await goToTeeSheet(page);\n  console.log('‚û°Ô∏è Navigated to tee sheet (or already there)');\n  console.log('‚è≥ Waiting for tee sheet...');\n  await waitForTeeSheet(page);\n  console.log('‚úÖ Tee sheet ready');\n\n  // Use rootForTee(page) later to select the correct root (iframe-aware)\n\n  // Optionally open the calendar and select the target date (if parsed)\n  const targetDay = env.TARGET_DAY;\n  if (targetDay) {\n    await openCalendar(page);\n    const ok = await selectCalendarDay(page, targetDay);\n    if (!ok) throw new Error(`Could not find enabled day \"${targetDay}\" in the calendar (tried 12 months)`);\n    console.log('‚è≥ Waiting for tee sheet after date select...');\n    await waitForTeeSheet(page);\n    console.log('üìÖ Date applied, sheet reloaded');\n  }\n\n  // Wait for the tee-sheet rows to render. Different tee-sheet UIs use\n  // different classes/structures, so try several common selectors and\n  // fall back to waiting for any time string to appear.\n  const rowsSelectors = '.tee-row, .tee-time-row, tr.tee-row, .slot-row, .slot, .timeslot, .time-slot, .availability, .tee-time, .teeRow';\n  const rows = page.locator(rowsSelectors);\n\n  const rowsVisible = await rows.first().isVisible().catch(() => false);\n  if (rowsVisible) {\n    await expect(rows.first()).toBeVisible({ timeout: 10000 });\n  } else {\n    // Fallback: wait for any time-like pattern to appear on the page\n    const timePatternFallback = page.locator('text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/').first();\n    console.log('‚ö†Ô∏è Rows selectors did not match; falling back to waiting for any time-like text');\n    await timePatternFallback.waitFor({ state: 'visible', timeout: 15000 });\n  }\n\n  // Helper: resilient OR-style readiness check for the tee sheet\n  async function waitForTeeSheet(page: import('@playwright/test').Page) {\n    // Log URL + title to aid debugging\n    console.log('URL:', page.url());\n    try { console.log('Title:', await page.title()); } catch {}\n\n    // Accept cookie banners if present\n    const cookie = page.locator('button:has-text(\"Accept\"), button:has-text(\"I Agree\")').first();\n    if (await cookie.isVisible().catch(() => false)) await cookie.click().catch(() => {});\n\n    // Define signals that the tee sheet is actually rendered.\n    const dateHeader = page.locator('button', { hasText: /JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC/i }).first();\n    const anyTime = page.locator('text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/').first();\n    const anyAction = page.locator('button:has-text(\"Book\"), button:has-text(\"Waiting\"), a:has-text(\"Book\"), [role=\"button\"]:has-text(\"Book\")').first();\n\n    // Wait for any ONE of these to become visible.\n    const start = Date.now();\n    while (Date.now() - start < 30000) {\n      if (await dateHeader.isVisible().catch(() => false)) { console.log('‚úÖ date header visible'); return; }\n      if (await anyTime.isVisible().catch(() => false))   { console.log('‚úÖ a tee time is visible'); return; }\n      if (await anyAction.isVisible().catch(() => false)) { console.log('‚úÖ a booking action is visible'); return; }\n      await page.waitForTimeout(300);\n    }\n    throw new Error('Tee sheet not detected within 30s (no date header, times, or buttons).');\n  }\n\n  // Iterate preferred times\n  // Acquire root (iframe-aware) for subsequent locators\n  // Use `let` so we can refresh the root if the calendar navigation changes iframes\n  let root = await rootForTee(page);\n\n  // Ensure the page (or iframe root) contains at least one time-like pattern before scanning specific targets\n  const timePattern = root.locator('text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/');\n  await timePattern.first().waitFor({ state: 'visible', timeout: 15000 }).catch(() => {});\n\n  console.log('üîé Looking for time...', env.TARGET_TIMES.join(', '));\n  // Helper: read visible times on the provided root and return sorted array of 'HH:MM' strings\n  async function getVisibleTimes(root: any) {\n    const texts = await root.locator('text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/').allTextContents();\n    const set = new Set<string>();\n    for (const txtRaw of texts) {\n      const txt = (txtRaw ?? '').trim();\n      const m = txt.match(/(\\d{1,2}:\\d{2})/);\n      if (m && m[1]) set.add(m[1].padStart(5, '0'));\n    }\n    // Sort times ascending (defensive parsing)\n    return Array.from(set).sort((a, b) => {\n      const [ahStr = '0', amStr = '0'] = a.split(':');\n      const [bhStr = '0', bmStr = '0'] = b.split(':');\n      const ah = parseInt(ahStr, 10) || 0;\n      const am = parseInt(amStr, 10) || 0;\n      const bh = parseInt(bhStr, 10) || 0;\n      const bm = parseInt(bmStr, 10) || 0;\n      return ah * 60 + am - (bh * 60 + bm);\n    });\n  }\n\n  const availableTimes = await getVisibleTimes(root);\n  console.log('‚ÑπÔ∏è Available times on page:', availableTimes.join(', ') || '<none>');\n\n  // For each preferred time, find the first available time >= preferred\n  const desiredCandidates: string[] = [];\n  for (const pref of env.TARGET_TIMES) {\n    const [phStr = '0', pmStr = '0'] = pref.split(':');\n    const ph = parseInt(phStr, 10) || 0;\n    const pm = parseInt(pmStr, 10) || 0;\n    const prefMinutes = ph * 60 + pm;\n    const candidate = availableTimes.find((t) => {\n      const [thStr = '0', tmStr = '0'] = t.split(':');\n      const th = parseInt(thStr, 10) || 0;\n      const tm = parseInt(tmStr, 10) || 0;\n      return th * 60 + tm >= prefMinutes;\n    });\n    if (candidate) desiredCandidates.push(candidate);\n  }\n\n  if (desiredCandidates.length === 0) {\n    console.log('‚ö†Ô∏è No available times meet preferred windows; available times:', availableTimes.join(', '));\n    // continue with original exact-match attempt (to keep behavior) by iterating env.TARGET_TIMES\n  }\n\n  const candidatesToTry = Array.from(new Set(desiredCandidates.length > 0 ? desiredCandidates : env.TARGET_TIMES));\n  // Forward-search fallback: scan current date for actionable slots, and if none\n  // are found, hop forward up to SEARCH_DAYS to find the next actionable date.\n  function toISO(d: Date) {\n    const y = d.getFullYear();\n    const m = String(d.getMonth() + 1).padStart(2, '0');\n    const day = String(d.getDate()).padStart(2, '0');\n    return `${y}-${m}-${day}`;\n  }\n\n  async function scanCurrentDateForActionable(root: any, preferredTimes: string[], clickWaitlist: boolean) {\n    const timeRegex = /\\b(?:0?\\d|1\\d|2[0-3]):[0-5]\\d\\b/;\n    const table = root.locator('table:has(tr), [role=\"grid\"]:has(tr)').first();\n    if (!await table.isVisible().catch(()=>false)) return { found: false };\n\n    const rows = table.locator('tbody tr, tr');\n    const count = await rows.count();\n    const results: Array<{time:string, canBook:boolean, canWait:boolean, row:any, bookBtn:any, waitBtn:any}> = [];\n\n    for (let i=0;i<count;i++){\n      const row = rows.nth(i);\n      const txt = (await row.innerText().catch(()=>'')) || '';\n      const times = txt.match(new RegExp(timeRegex,'g')) || [];\n      const time = times[0]?.trim();\n      if (!time) continue;\n\n      const bookBtn = row.locator(':is(button,a,[role=\"button\"],.btn):has-text(/\\\\bbook\\\\b/i)').first();\n      const waitBtn = row.locator(':is(button,a,[role=\"button\"],.btn):has-text(/waiting( list)?/i)').first();\n      const canBook = await bookBtn.isVisible().catch(()=>false);\n      const canWait = await waitBtn.isVisible().catch(()=>false);\n\n      results.push({ time, canBook, canWait, row, bookBtn, waitBtn });\n    }\n\n    console.log('üóíÔ∏è Slots summary:', results.map(r => `${r.time} ‚Äî ${r.canBook ? 'Book' : r.canWait ? 'Waiting' : 'Unavailable'}`).join(', '));\n\n    const toMins = (t:string)=>{ const [h='0',m='0']=t.split(':'); return Number(h)*60+Number(m); };\n    const pref = preferredTimes.map(t=>t.trim()).filter(Boolean);\n    for (const p of pref){\n      const pm = toMins(p);\n      const cand = results.filter(r => (r.canBook || (clickWaitlist && r.canWait)))\n                          .sort((a,b)=>toMins(a.time)-toMins(b.time))\n                          .find(r => toMins(r.time) >= pm);\n      if (cand) return { found:true, chosen:cand };\n    }\n    const any = results.filter(r => (r.canBook || (clickWaitlist && r.canWait))).sort((a,b)=>toMins(a.time)-toMins(b.time))[0];\n    if (any) return { found:true, chosen:any };\n    return { found:false };\n  }\n    // Helper: split YYYY-MM-DD into numeric y/m/d\n    function splitISO(iso: string) {\n      const [y, m, d] = iso.split('-').map(Number);\n      return { y, m, d };\n    }\n    async function gotoTeeDate(page: import('@playwright/test').Page, iso: string) {\n      const { y, m, d } = splitISO(iso);\n      const url = `https://members.brsgolf.com/galgorm/tee-sheet/1/${y}/${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}`;\n      console.log('üîó Navigating to date URL:', url);\n      await page.goto(url, { waitUntil: 'domcontentloaded' });\n    }\n\n    const root0 = await rootForTee(page);\n    let activeDateISO = env.RAW_TARGET_DATE || toISO(new Date());\n    let found = await scanCurrentDateForActionable(root0, env.TARGET_TIMES, env.CLICK_WAITLIST);\n\n    for (let hop = 0; !found.found && hop < SEARCH_DAYS; hop++) {\n      const base = new Date(activeDateISO);\n      base.setDate(base.getDate() + 1);\n      activeDateISO = toISO(base);\n      console.log(`‚û°Ô∏è No actionable slots; trying ${activeDateISO} by URL`);\n\n      await gotoTeeDate(page, activeDateISO);\n      console.log('‚è≥ Waiting for tee sheet after URL hop...');\n      await waitForTeeSheet(page);\n\n      const rootNext = await rootForTee(page);\n      found = await scanCurrentDateForActionable(rootNext, env.TARGET_TIMES, env.CLICK_WAITLIST);\n    }\n\n    if (!found.found) throw new Error(`No bookable or waiting-list slots found within ${SEARCH_DAYS} day(s).`);\n\n    const chosen = found.chosen!;\n    const actionType = chosen.canBook ? 'Book' : 'Waiting';\n    console.log(`üéØ Selected ${actionType} @ ${chosen.time} on ${activeDateISO}`);\n\n    if (env.DRY_RUN) {\n      console.log(`üß™ DRY-RUN: would click ${actionType} for ${chosen.time} on ${activeDateISO}`);\n      return;\n    }\n\n    const btn = chosen.canBook ? chosen.bookBtn : chosen.waitBtn;\n    try { await btn.scrollIntoViewIfNeeded(); } catch {}\n    await btn.click();\n    const success = page.locator('text=/Booking|Booked|Confirmed|Confirmation|Waiting list|Added to waiting list/i').first();\n    await expect(success).toBeVisible({ timeout: 12000 });\n    console.log('üéâ Flow reached success message');\n\n    return;\n});\n",
    "tests/sniper.spec.ts": "import 'dotenv/config';\nimport { test, expect } from '@playwright/test';\n\n// Async loader for date-fns-tz to handle ESM/CJS differences at runtime\nasync function getZonedTimeToUtc() {\n  try {\n    const mod = await import('date-fns-tz');\n    return (mod as any).zonedTimeToUtc ?? (mod as any).default?.zonedTimeToUtc ?? (mod as any);\n  } catch (e) {\n    const { createRequire } = await import('module');\n    const req = createRequire(import.meta.url);\n    const _df = req('date-fns-tz');\n    return _df.zonedTimeToUtc ?? _df.default?.zonedTimeToUtc ?? _df;\n  }\n}\n\n// Use authenticated state saved previously\ntest.use({ storageState: 'state.json' });\n\n// Small helpers\nfunction toISO(d: Date) {\n  const y = d.getFullYear();\n  const m = String(d.getMonth() + 1).padStart(2, '0');\n  const day = String(d.getDate()).padStart(2, '0');\n  return `${y}-${m}-${day}`;\n}\n\nfunction splitISO(iso: string) {\n  const [y, m, d] = iso.split('-').map(Number);\n  return { y, m, d };\n}\n\n// Timezone-aware release configuration\nconst TZ = process.env.FS_TZ || 'Europe/London';\nconst RELEASE_AT_LOCAL = process.env.FS_RELEASE_AT_LOCAL || '';\nlet RELEASE_AT: Date | null = null;\n\nconst FS_DRY_RUN = (process.env.FS_DRY_RUN ?? 'true').toLowerCase() === 'true';\nconst CLICK_WAITLIST = (process.env.FS_CLICK_WAITLIST ?? 'false').toLowerCase() === 'true';\nconst COURSE_ID = process.env.FS_COURSE_ID ?? '1';\nconst TARGET_DATE = process.env.FS_TARGET_DATE ?? toISO(new Date());\nconst TARGET_TIMES = (process.env.FS_TARGET_TIMES ?? '').split(',').map(s => s.trim()).filter(Boolean);\n\nconst WINDOW_BEFORE_MS = Number(process.env.FS_WINDOW_BEFORE_MS ?? '30000');\nconst WINDOW_AFTER_MS = Number(process.env.FS_WINDOW_AFTER_MS ?? '30000');\nconst REFRESH_HZ = Number(process.env.FS_REFRESH_HZ ?? '1');\nconst POLL_MS = Number(process.env.FS_POLL_MS ?? '15');\n\n// Small iframe-aware root helper (minimal, independent)\nasync function rootForTee(page: import('@playwright/test').Page) {\n  const candidates = ['iframe[src*=\"tee\"]', 'iframe[id*=\"tee\"]', 'iframe[src*=\"sheet\"]', 'iframe'];\n  const timePattern = 'text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/';\n  for (const sel of candidates) {\n    try {\n      const count = await page.locator(sel).count();\n      if (count === 0) continue;\n      const fl = page.frameLocator(sel);\n      const hasTime = await fl.locator(timePattern).first().count().catch(() => 0);\n      if (hasTime > 0) return fl;\n    } catch {\n      // ignore\n    }\n  }\n  return page;\n}\n\n// Find action buttons in a table row that contains the time string\nasync function findActionForTime(root: any, time: string) {\n  const table = root.locator('table:has(tr), [role=\"grid\"]:has(tr)').first();\n  if (!await table.isVisible().catch(() => false)) return { bookBtn: null, waitBtn: null, row: null };\n  const rows = table.locator('tbody tr, tr');\n  const count = await rows.count();\n  for (let i = 0; i < count; i++) {\n    const row = rows.nth(i);\n    const firstCell = row.locator('td, [role=\"gridcell\"]').first();\n    const txt = (await firstCell.innerText().catch(() => '')).trim();\n    if (txt === time) {\n      const actionCell = row.locator('td, [role=\"gridcell\"]').nth(1).or(row);\n      const bookBtn = actionCell.locator(':is(button,a,[role=\"button\"]):has-text(/\\\\bbook\\\\b/i)').first();\n      const waitBtn = actionCell.locator(':is(button,a,[role=\"button\"]):has-text(/waiting( list)?/i)').first();\n      return { bookBtn, waitBtn, row };\n    }\n  }\n  return { bookBtn: null, waitBtn: null, row: null };\n}\n\n// Navigation to specific tee-sheet date URL\nasync function gotoTeeDate(page: import('@playwright/test').Page, courseId: string, iso: string) {\n  const { y, m, d } = splitISO(iso);\n  const url = `https://members.brsgolf.com/galgorm/tee-sheet/${courseId}/${y}/${String(m).padStart(2,'0')}/${String(d).padStart(2,'0')}`;\n  console.log('üîó Navigating to date URL:', url);\n  await page.goto(url, { waitUntil: 'domcontentloaded' });\n}\n\ntest.describe('sniper', () => {\n  test('fire on release', async ({ page }) => {\n    test.setTimeout(5 * 60 * 1000);\n\n    console.log('‚öôÔ∏è Sniper config', {\n      dryRun: FS_DRY_RUN,\n      tz: TZ,\n      releaseAtLocal: RELEASE_AT_LOCAL || null,\n      courseId: COURSE_ID,\n      targetDate: TARGET_DATE,\n      targetTimes: TARGET_TIMES,\n      clickWaitlist: CLICK_WAITLIST,\n      windowBeforeMs: WINDOW_BEFORE_MS,\n      windowAfterMs: WINDOW_AFTER_MS,\n      refreshHz: REFRESH_HZ,\n    });\n\n    // Compute RELEASE_AT at runtime to avoid module load issues\n    if (RELEASE_AT_LOCAL) {\n      const _z = await getZonedTimeToUtc();\n      try {\n        RELEASE_AT = _z(RELEASE_AT_LOCAL, TZ);\n        if (RELEASE_AT) console.log('üïí Parsed RELEASE_AT (UTC):', RELEASE_AT.toISOString());\n      } catch (e) {\n        console.log('‚ö†Ô∏è Could not parse RELEASE_AT_LOCAL with date-fns-tz:', e);\n        RELEASE_AT = null;\n      }\n    }\n\n    // Block heavy resources at context-level to reduce latency\n    await page.context().route('**/*', (route) => {\n      const req = route.request();\n      const t = req.resourceType();\n      if (['image', 'font', 'media', 'stylesheet'].includes(t)) return route.abort();\n      const u = req.url();\n      if (/analytics|googletagmanager|facebook|doubleclick/i.test(u)) return route.abort();\n      return route.continue();\n    });\n\n    // Navigate to target date\n    await gotoTeeDate(page, COURSE_ID, TARGET_DATE);\n\n    // Wait for tee sheet signals (reuse simple heuristics)\n    const waitForTeeSheet = async () => {\n      const anyTime = page.locator('text=/\\\\b(?:0?\\\\d|1\\\\d|2[0-3]):[0-5]\\\\d\\\\b/').first();\n      const start = Date.now();\n      while (Date.now() - start < 30000) {\n        if (await anyTime.isVisible().catch(() => false)) return;\n        await page.waitForTimeout(200);\n      }\n      throw new Error('Tee sheet not detected');\n    };\n\n    await waitForTeeSheet();\n\n    // Precompute row locators for preferred times (sensors)\n    let root = await rootForTee(page);\n    const sensors: Array<{ time: string; }> = TARGET_TIMES.map(t => ({ time: t }));\n\n  const releaseMs = RELEASE_AT instanceof Date ? RELEASE_AT.getTime() : Date.now();\n    const startMs = Math.max(0, releaseMs - WINDOW_BEFORE_MS);\n    const endMs = releaseMs + WINDOW_AFTER_MS;\n\n    console.log(`üïí Waiting window: ${new Date(startMs).toISOString()} -> ${new Date(endMs).toISOString()}`);\n\n    // Busy-wait loop with light reload bursts\n    let performed = false;\n    let lastReload = 0;\n    const reloadIntervalMs = REFRESH_HZ > 0 ? Math.round(1000 / REFRESH_HZ) : 1000;\n\n    // ensure we don't spin too early\n    while (Date.now() < startMs) {\n      const toWait = Math.min(100, startMs - Date.now());\n      await page.waitForTimeout(toWait);\n    }\n\n    // Main scanning loop\n    while (Date.now() <= endMs && !performed) {\n      // reload bursts\n      if (Date.now() - lastReload >= reloadIntervalMs) {\n        try { await page.reload({ waitUntil: 'domcontentloaded' }); } catch {}\n        lastReload = Date.now();\n        // refresh root after reload\n        root = await rootForTee(page);\n      }\n\n      // tight DOM polling\n      for (const s of sensors) {\n        const { bookBtn, waitBtn } = await findActionForTime(root, s.time);\n        // check book button\n        if (bookBtn && await bookBtn.isVisible().catch(() => false)) {\n          const btn = bookBtn;\n          console.log(`‚ö° Detected Book for ${s.time}`);\n          if (FS_DRY_RUN) { console.log(`DRY-RUN: would click Book @ ${s.time}`); performed = true; break; }\n          // attempt quick retries\n          let clicked = false;\n          for (let attempt = 0; attempt < 3 && !clicked; attempt++) {\n            try { await btn.scrollIntoViewIfNeeded(); await btn.click({ timeout: 2000 }); clicked = true; } catch (e) { await page.waitForTimeout(80); }\n          }\n          if (clicked) {\n            // wait for success cue\n            const success = page.locator('text=/Booking|Booked|Confirmed|Confirmation|Waiting list|Added to waiting list/i').first();\n            await expect(success).toBeVisible({ timeout: 12000 });\n            console.log(`üéâ Book click succeeded for ${s.time}`);\n            performed = true; break;\n          }\n        }\n\n        // fallback to waiting list if allowed\n        if (CLICK_WAITLIST && waitBtn && await waitBtn.isVisible().catch(() => false)) {\n          console.log(`‚ö° Detected Waiting for ${s.time}`);\n          if (FS_DRY_RUN) { console.log(`DRY-RUN: would click Waiting @ ${s.time}`); performed = true; break; }\n          let clicked = false;\n          for (let attempt = 0; attempt < 3 && !clicked; attempt++) {\n            try { await waitBtn.scrollIntoViewIfNeeded(); await waitBtn.click({ timeout: 2000 }); clicked = true; } catch (e) { await page.waitForTimeout(80); }\n          }\n          if (clicked) {\n            const success = page.locator('text=/Booking|Booked|Confirmed|Confirmation|Waiting list|Added to waiting list/i').first();\n            await expect(success).toBeVisible({ timeout: 12000 });\n            console.log(`üéâ Waiting click succeeded for ${s.time}`);\n            performed = true; break;\n          }\n        }\n      }\n\n      if (performed) break;\n      // tight poll\n      await page.waitForTimeout(POLL_MS);\n    }\n\n    if (!performed) {\n      console.log('‚è≥ No actionable slots detected during window');\n    }\n  });\n});\n",
    "types/date-fns-tz.d.ts": "declare module 'date-fns-tz' {\n  export function zonedTimeToUtc(date: string | Date, timeZone: string): Date;\n}\n"
  },
  "testReport": null
}